<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MEDUSA PROJECT: [Titre] # MULTITHREADING VISUALISATION &amp; SOLUTION  (ThreadVS)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MEDUSA PROJECT
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__r_e_a_d_m_e.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">[Titre] # MULTITHREADING VISUALISATION &amp; SOLUTION (ThreadVS)</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1"></a></p>
<h1><a class="anchor" id="autotoc_md2"></a>
About</h1>
<p>[Titre du projet] aims to debug C++ multithreaded programs by visualizing threads executions. It provides a C++ Backend Recursive Dispatch Queue API accessible to the user. This API includes functionalities to log user code at different levels and generates a JSON file. This file is then used by a Python-based graphical user interface (GUI) to visualize the program‚Äôs execution.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Table of contents</h1>
<ul>
<li>ü™ß About</li>
<li>üì¶ System Requirements</li>
<li>üöÄ Installing</li>
<li>üõ†Ô∏è Utilisation<ul>
<li>Backend</li>
<li>Frontend (GUI)</li>
</ul>
</li>
<li>‚úÖ Exemples</li>
<li>ü§ù Contribution</li>
<li>üèóÔ∏è Build with</li>
<li>üìö Documentation</li>
<li>üìù Licence</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
Building</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
Supported Operating Systems</h2>
<ul>
<li>Linux (g++ / clang)</li>
<li>macOS (XCode)</li>
<li>Windows (Visual Studio)</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
System Requirements</h1>
<ul>
<li>C++17 Compiler</li>
<li>Python 3.x</li>
</ul>
<h1><a class="anchor" id="autotoc_md7"></a>
Installing</h1>
<p><code>git clone [a ajouter githhub lien]</code> <br  />
</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Utilisation</h1>
<h2><a class="anchor" id="autotoc_md9"></a>
Backend</h2>
<p>The backend program is a C++ code that provides a Recursive Dispatch Queue (DispatchQ class). <br  />
 It manages a pool of worker threads to execute tasks asynchronously. It provides functionality for dispatching tasks, managing thread pools, and logging task execution details. Here's a breakdown of how to use the backend part of this code : <br  />
</p>
<h3><a class="anchor" id="autotoc_md10"></a>
Initialization :</h3>
<p>To start using the DispatchQ, you need to create an instance of it. You can specify the name of the queue and the number of worker threads. </p><div class="fragment"><div class="line"><span class="comment">// Creates a queue named &quot;MyQueue&quot; with 4 worker threads</span></div>
<div class="line"><a class="code hl_class" href="class_lz_async_1_1_dispatch_q.html">LzAsync::DispatchQ</a> dispatchQueue(<span class="stringliteral">&quot;MyQueue&quot;</span>, 4);</div>
<div class="ttc" id="aclass_lz_async_1_1_dispatch_q_html"><div class="ttname"><a href="class_lz_async_1_1_dispatch_q.html">LzAsync::DispatchQ</a></div><div class="ttdoc">The DispatchQ class.</div><div class="ttdef"><b>Definition</b> DispatchQ.h:76</div></div>
</div><!-- fragment --> <hr  />
<h3><a class="anchor" id="autotoc_md12"></a>
Dispatch a job</h3>
<p>These are functions to put a job in the dispatch queue. Your job can also dispatch other jobs recursively. Make sure your algorithm has a proper termination condition. </p><div class="fragment"><div class="line"><span class="comment">// Here func is std::function&lt;void(void)&gt;</span></div>
<div class="line"><span class="comment">// Where func_and_name is std::pair&lt;const std::string, func&gt;</span></div>
<div class="line"><span class="keywordtype">void</span> dispatch( <span class="keyword">const</span> func &amp; pJob, <span class="keyword">const</span> <span class="keywordtype">string</span> &amp; pName=<span class="stringliteral">&quot;&lt;unnamed&gt;&quot;</span> );</div>
<div class="line"><span class="keywordtype">void</span> dispatch( <span class="keyword">const</span> vector&lt;func&gt; &amp; pJobs, <span class="keyword">const</span> <span class="keywordtype">string</span> &amp; pName=<span class="stringliteral">&quot;&lt;unnamed&gt;&quot;</span> );</div>
<div class="line"><span class="keywordtype">void</span> dispatch( <span class="keyword">const</span> List&lt;func&gt; &amp; pJobs, <span class="keyword">const</span> <span class="keywordtype">string</span> &amp; pName=<span class="stringliteral">&quot;&lt;unnamed&gt;&quot;</span> );</div>
<div class="line"><span class="keywordtype">void</span> dispatch( func_and_name &amp;&amp; pNamedJob );</div>
<div class="line"><span class="keywordtype">void</span> dispatch( <span class="keyword">const</span> List&lt;func_and_name&gt; &amp; pNamedJobs );</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md13"></a>
Example Usage :</h3>
<p>dispatch the function lambda (that call "RecursiveCount") to the dispatch queue <br  />
 (see TestRecursiveDQ__Counter in DispatchQ_UnitTest) </p><div class="fragment"><div class="line">spTestAsyncDQ-&gt;dispatch</div>
<div class="line">   ( </div>
<div class="line">       [&amp;]{ RecursiveCount( lInts, lSum ); }, </div>
<div class="line">       <span class="stringliteral">&quot;RecursiveCount : with size = &quot;</span> + std::to_string(lInts-&gt;size())</div>
<div class="line">   );</div>
</div><!-- fragment --><hr  />
<h3><a class="anchor" id="autotoc_md15"></a>
Managing the Thread Pool</h3>
<p>You can manage the thread pool using the following methods :</p>
<ol type="1">
<li>Wait for Idle : <div class="fragment"><div class="line"><span class="comment">// Blocking waits until the Queue is empty AND no more workers are doing any work</span></div>
<div class="line">dispatchQueue.waitForIdle(<span class="keywordtype">bool</span> pRestart); </div>
</div><!-- fragment --></li>
<li>Complete <a class="el" href="class_jobs.html" title="Fundamental executable job unit.">Jobs</a> : <div class="fragment"><div class="line"><span class="comment">// Blocking waits for proper termination of all jobs in queue</span></div>
<div class="line">dispatchQueue.completeJobs(<span class="keywordtype">bool</span> pRestart); </div>
</div><!-- fragment --></li>
<li>Interrupt <a class="el" href="class_jobs.html" title="Fundamental executable job unit.">Jobs</a> : <div class="fragment"><div class="line"><span class="comment">// Blocking waits for proper termination of all jobs in queue</span></div>
<div class="line">dispatchQueue.interruptJobs(<span class="keywordtype">bool</span> pRestart); </div>
</div><!-- fragment --></li>
</ol>
<p>If <code>pRestart</code> is at true, the dispatch queue will be restarted with same number of workers. <br  />
 ‚ö†Ô∏è Warning : Those functions are BLOCKING.</p>
<ol type="1">
<li>Restart Pool : <div class="fragment"><div class="line"><span class="comment">// Will INTERRUPT all jobs, and terminate all current worker threads before restarting. Here restart with 8 threads</span></div>
<div class="line">dispatchQueue.restartPool(8);</div>
</div><!-- fragment --></li>
</ol>
<hr  />
<h3><a class="anchor" id="autotoc_md17"></a>
Logging and Exporting Logs</h3>
<p>Logs are automatically managed based on the logging mode specified when starting profiling. Logs are stored in JSON format and include details about task execution, mutex states, and tags. <br  />
 Logs can be exported in two modes :</p><ol type="1">
<li>END Mode : <div class="fragment"><div class="line">dispatchQueue.startProfiling(<span class="stringliteral">&quot;/path/to/logs&quot;</span>);</div>
<div class="line"><span class="comment">// Or</span></div>
<div class="line">dispatchQueue.startProfiling(<span class="stringliteral">&quot;/path/to/logs&quot;</span>, <a class="code hl_enumvalue" href="namespace_lz_async.html#a042255cfe6266c279099b1238d39443aab1a326c06d88bf042f73d70f50197905">LzAsync::LogsMod::END</a>);</div>
<div class="ttc" id="anamespace_lz_async_html_a042255cfe6266c279099b1238d39443aab1a326c06d88bf042f73d70f50197905"><div class="ttname"><a href="namespace_lz_async.html#a042255cfe6266c279099b1238d39443aab1a326c06d88bf042f73d70f50197905">LzAsync::LogsMod::END</a></div><div class="ttdeci">@ END</div><div class="ttdef"><b>Definition</b> DispatchQ.h:57</div></div>
</div><!-- fragment --> Logs are exported at the end of execution as a <code>logs.json</code> file in the specified path. <br  />
 ‚ö†Ô∏è Warning : The path must exist.</li>
<li>REALTIME Mode : <div class="fragment"><div class="line">dispatchQueue.startProfiling(<span class="stringliteral">&quot;/path/to/logs&quot;</span>, <a class="code hl_enumvalue" href="namespace_lz_async.html#a042255cfe6266c279099b1238d39443aa4abfc22ad3c3ef567d80c65263fd7754">LzAsync::LogsMod::REALTIME</a>);</div>
<div class="ttc" id="anamespace_lz_async_html_a042255cfe6266c279099b1238d39443aa4abfc22ad3c3ef567d80c65263fd7754"><div class="ttname"><a href="namespace_lz_async.html#a042255cfe6266c279099b1238d39443aa4abfc22ad3c3ef567d80c65263fd7754">LzAsync::LogsMod::REALTIME</a></div><div class="ttdeci">@ REALTIME</div><div class="ttdef"><b>Definition</b> DispatchQ.h:57</div></div>
</div><!-- fragment --> Logs are exported in real-time in <code>"/path/to/logs"</code> directory. It exports the last 10 modifications. If the user wants to have more or minus last modifications he can modify the <code>constexpr</code> variable <code>NB_FILE</code> in <code>DispatchQ::ExportRealTimeJson</code> function. The format of the files are <code>"_LOG_&lt;TimeStamp&gt;.json"</code> where <code>TimeStamp</code> is the time since the start of profiling. <br  />
 ‚ö†Ô∏è Warning : In real-time logs the program deletes all files matching the naming format.</li>
</ol>
<p>To stop profiling during the execution you can call : </p><div class="fragment"><div class="line">dispatchQueue.stopProfiling();</div>
</div><!-- fragment --><p> After that you can re-call <code>DispatchQ::startProfiling(...)</code>. <br  />
 ‚ö†Ô∏è Warning (only on END mod) : if you call <code>DispatchQ::stopProfiling()</code> and then <code>DispatchQ::startProfiling(...)</code> the previous logs will be deleted, so you must call <code>DispatchQ::ExportLogsJson(std::string pToDir)</code> EXPICITLY before re-call <code>DispatchQ::startProfiling(...)</code>.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Example Usage</h3>
<p>Here's an example of how you might use the DispatchQ class :</p>
<div class="fragment"><div class="line"><span class="comment">// Import the DispatchQ header</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_dispatch_q_8h.html">DispatchQ.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> VerySimpleTest()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create a DispatchQ with the name &quot;VerySimpleTest&quot; and 3 worker threads</span></div>
<div class="line">    <a class="code hl_class" href="class_lz_async_1_1_dispatch_q.html">LzAsync::DispatchQ</a> dispatchQ(<span class="stringliteral">&quot;VerySimpleTest&quot;</span>, 3);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define a small job (simulate some short work with sleep)</span></div>
<div class="line">    <span class="keyword">auto</span> Smalljob = [&amp;]()</div>
<div class="line">    {</div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(50));</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Define a bigger job that will itself dispatch more small jobs</span></div>
<div class="line">    <span class="keyword">auto</span> Bigjob = [&amp;]()</div>
<div class="line">    {</div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Dynamically dispatch 3 small jobs from within this job</span></div>
<div class="line">        dispatchQ.dispatch(Smalljob, <span class="stringliteral">&quot;Fifth Dispatch&quot;</span>);</div>
<div class="line">        dispatchQ.dispatch(Smalljob, <span class="stringliteral">&quot;Sixth Dispatch&quot;</span>);</div>
<div class="line">        dispatchQ.dispatch(Smalljob, <span class="stringliteral">&quot;Seventh Dispatch&quot;</span>);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define a job that dispatches other jobs, including Bigjob</span></div>
<div class="line">    <span class="keyword">auto</span> job2 = [&amp;]()</div>
<div class="line">    {</div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(50));</div>
<div class="line"> </div>
<div class="line">        dispatchQ.dispatch(Smalljob, <span class="stringliteral">&quot;Second Dispatch&quot;</span>);</div>
<div class="line">        dispatchQ.dispatch(Smalljob, <span class="stringliteral">&quot;Third Dispatch&quot;</span>);</div>
<div class="line">        dispatchQ.dispatch(Bigjob, <span class="stringliteral">&quot;Fourth Dispatch&quot;</span>);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start profiling and specify output directory for logs</span></div>
<div class="line">    dispatchQ.startProfiling(<span class="stringliteral">&quot;./json_files/VerySimpleTest&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Dispatch the main job</span></div>
<div class="line">    dispatchQ.dispatch(job2, <span class="stringliteral">&quot;First Dispatch&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait until all jobs are finished</span></div>
<div class="line">    dispatchQ.waitForIdle(<span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="ttc" id="a_dispatch_q_8h_html"><div class="ttname"><a href="_dispatch_q_8h.html">DispatchQ.h</a></div></div>
</div><!-- fragment --><p>This will generate <code>"./json_files/VerySimpleTest.json"</code>.</p>
<p>This is what you should see in the GUI: <br  />
 <img src="Screenshots_ReadMe/VerySimpleTestSuccess.png" alt="Very Simple Test ‚Äì Success" class="inline"/> <br  />
 <img src="Screenshots_ReadMe/VerySimpleTestError.png" alt="Very Simple Test ‚Äì Error" class="inline"/></p>
<blockquote class="doxtable">
<p><b>What You See:</b> <br  />
</p><ul>
<li>Each rectangle represents a job. <br  />
</li>
<li>üü© <b>Green</b> rectangle indicates that the job completed successfully. <br  />
</li>
<li>üü• <b>Red</b> rectangle indicates that the job threw an exception, which was caught by the dispatch queue.</li>
<li>When you hover over a rectangle, you will see detailed information about the job: <br  />
</li>
<li>Job name <br  />
</li>
<li>Job ID (see Heredity) <br  />
</li>
<li>Parent job ID (see Heredity) <br  />
</li>
<li>Start and stop times <br  />
</li>
<li>Job duration <br  />
</li>
<li>(For red rectangles) Any caught exceptions </li>
</ul>
</blockquote>
<hr  />
<h3><a class="anchor" id="autotoc_md20"></a>
Mutexes Management</h3>
<p>The DispatchQ class provides a way to manage and log mutex states. This is useful for debugging and profiling, especially in multi-threaded environments where mutex behavior is critical. <br  />
 Here's how you can use the mutex management features :</p>
<ol type="1">
<li>Mutex Need : Log when a thread is about to attempt to lock a mutex. <div class="fragment"><div class="line">std::mutex mtx;</div>
<div class="line">MutexNeed(dispatchQueue, <span class="stringliteral">&quot;mtx&quot;</span>);</div>
<div class="line">mtx.lock();</div>
</div><!-- fragment --></li>
<li>Mutex Have: Log when a thread has successfully locked a mutex. <div class="fragment"><div class="line">mtx.lock();</div>
<div class="line">MutexHave(dispatchQueue, <span class="stringliteral">&quot;mtx&quot;</span>);</div>
<div class="line"><span class="comment">// Critical section</span></div>
</div><!-- fragment --></li>
<li>Mutex Free: Log when a thread has unlocked a mutex. <div class="fragment"><div class="line">mtx.unlock();</div>
<div class="line">MutexFree(dispatchQueue, <span class="stringliteral">&quot;mtx&quot;</span>);</div>
</div><!-- fragment --> These functions help track the lifecycle of mutex operations, which can be useful for identifying potential deadlocks or performance bottlenecks. <br  />
 ‚ö†Ô∏è‚ö†Ô∏è WARNING : You must use <b>ALL three functions</b> to log a mutex and the name of the mutex (here <code>"mtx"</code>) must be <b>EXACTLY the same in all Need, Have and Free for one mutex.</b> <br  />
 Of course it is possible to put several mutexes and then each of them must have a <b>unique name.</b> <br  />
</li>
</ol>
<h3><a class="anchor" id="autotoc_md21"></a>
Example Usage :</h3>
<p>Here's an example of how you might use mutex managment : (see <a class="el" href="_dispatch_q___unit_test_8cpp.html">DispatchQ_UnitTest.cpp</a>) </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_dispatch_q_8h.html">DispatchQ.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SimpleMutexTest() </div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_lz_async_1_1_dispatch_q.html">LzAsync::DispatchQ</a> queue(<span class="stringliteral">&quot;SimpleMutex&quot;</span>, 2);</div>
<div class="line">    queue.startProfiling(<span class="stringliteral">&quot;./json_files/SimpleMutex&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    std::mutex myMutex;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> jobMutex = [&amp;] </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Log before lock</span></div>
<div class="line">        MutexNeed(queue, <span class="stringliteral">&quot;MyCounterMutex&quot;</span>);  </div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(myMutex);</div>
<div class="line">        <span class="comment">// Log after lock</span></div>
<div class="line">        MutexHave(queue, <span class="stringliteral">&quot;MyCounterMutex&quot;</span>);  </div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Simulate some work</span></div>
<div class="line">        std::this_thread::sleep_for( std::chrono::milliseconds(100) );</div>
<div class="line">         </div>
<div class="line">        <span class="comment">// Log after the unlock</span></div>
<div class="line">        MutexFree(queue, <span class="stringliteral">&quot;MyCounterMutex&quot;</span>); </div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Jobs with mutex</span></div>
<div class="line">    queue.dispatch(jobMutex, <span class="stringliteral">&quot;IncrementTask 1&quot;</span>);</div>
<div class="line">    queue.dispatch(jobMutex, <span class="stringliteral">&quot;IncrementTask 2&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    queue.waitForIdle(<span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>This is what you should see in the GUI: <br  />
 <img src="Screenshots_ReadMe/SimpleMutex1.png" alt="Simple Mutex ‚Äì View 1" class="inline"/> <br  />
 <img src="Screenshots_ReadMe/SimpleMutex2.png" alt="Simple Mutex ‚Äì View 2" class="inline"/></p>
<blockquote class="doxtable">
<p><b>What You See:</b></p><ul>
<li>There are two jobs, and inside each job, you can see grey rectangles representing mutex activity. <br  />
</li>
<li>In this example, <b>Thread 2</b> acquires the mutex at time <code>0</code> and releases it at <code>101</code>. <b>Thread 1</b> starts trying to acquire the mutex at time <code>0</code>, obtains it at <code>101</code>, and releases it at <code>206</code>.</li>
<li>When you hover over a mutex rectangle, the following information is displayed: <br  />
<ul>
<li>Name of the mutex <br  />
</li>
<li>Time when the thread started trying to acquire it <br  />
</li>
<li>Time when the mutex was acquired <br  />
</li>
<li>Time when it was released</li>
<li>The <b>smaller, lighter grey</b> rectangle indicates the waiting period before acquiring the mutex. <br  />
</li>
<li>The <b>larger, darker grey</b> rectangle shows the time span during which the mutex was held, ending when the thread released it. </li>
</ul>
</li>
</ul>
</blockquote>
<hr  />
<h3><a class="anchor" id="autotoc_md23"></a>
Section Management (Tags)</h3>
<p>Tags in the DispatchQ class allow you to mark and measure specific sections of your code. This can be useful for profiling and understanding the execution flow of your application. <br  />
 Here's how you can use tags :</p>
<ol type="1">
<li>Tag Start: Mark the beginning of a section. <div class="fragment"><div class="line">TagStart(dispatchQueue, <span class="stringliteral">&quot;MySection&quot;</span>);</div>
<div class="line"><span class="comment">// Code section to profile</span></div>
</div><!-- fragment --></li>
<li>Tag Stop: Mark the end of a section. <div class="fragment"><div class="line"><span class="comment">// Code section to profile</span></div>
<div class="line">TagStop(dispatchQueue, <span class="stringliteral">&quot;MySection&quot;</span>);</div>
</div><!-- fragment --> These tags help in analyzing the time spent in different sections of your code, which can be useful for performance optimization. <br  />
 ‚ö†Ô∏è‚ö†Ô∏è WARNING : You have to use <b>ALL these two functions</b> to log a tag and the name of the section (here <code>"MySection"</code>) must be <b>EXACTLY the same in all two <code>TagStart</code> and <code>TagStop</code> functions of one section</b>. <br  />
 Of course it is possible to put several tags and then each of them must have a unique name. <br  />
 Be careful when using tags in nested loops: ensure <code>TagStart</code> and <code>TagStop</code> are properly paired and scoped.</li>
</ol>
<h3><a class="anchor" id="autotoc_md24"></a>
Example Usage :</h3>
<p>Here's an example of how you might use mutex managment : (see <a class="el" href="_dispatch_q___unit_test_8cpp.html">DispatchQ_UnitTest.cpp</a>) </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_dispatch_q_8h.html">DispatchQ.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> TestTagSimple()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create a new dispatch queue</span></div>
<div class="line">    <a class="code hl_class" href="class_lz_async_1_1_dispatch_q.html">LzAsync::DispatchQ</a> dispatchQ(<span class="stringliteral">&quot;TestTagSimple&quot;</span>, 1);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> jobTag = [&amp;]() </div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i&lt; 10 ; i++)</div>
<div class="line">        {   </div>
<div class="line">            <span class="comment">// Simulate some work</span></div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">            TagStart(dispatchQ, <span class="stringliteral">&quot;Tag&quot;</span>);</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Simulate some work</span></div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">            }</div>
<div class="line">            TagStop(dispatchQ, <span class="stringliteral">&quot;Tag&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start profiling</span></div>
<div class="line">    dispatchQ.startProfiling(<span class="stringliteral">&quot;./json_files/TestTagSimple&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Dispatch a job with a tag</span></div>
<div class="line">    dispatchQ.dispatch(jobTag, <span class="stringliteral">&quot;Job with Tag&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait for all jobs to finish</span></div>
<div class="line">    dispatchQ.waitForIdle(<span class="keyword">false</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is what you should see in the GUI: <br  />
 <img src="Screenshots_ReadMe/SimpleTag.png" alt="Simple Tag" class="inline"/></p>
<blockquote class="doxtable">
<p><b>What You See:</b></p><ul>
<li>Each <b>blue line</b> represents a tagged section of your code that was logged.</li>
<li>When you hover over a blue line, you will see detailed information about the tag:<ul>
<li>Tag name <br  />
</li>
<li>Start and stop timestamps <br  />
</li>
<li>Duration of the tagged section </li>
</ul>
</li>
</ul>
</blockquote>
<hr  />
<h3><a class="anchor" id="autotoc_md26"></a>
Real-Time Mode:</h3>
<p>In Real-Time Logs mode, JSON logs are continuously generated during your program‚Äôs execution. <br  />
 Each time a job completes, the logs are updated to reflect the current state of execution.</p>
<p>Additionally, if no job has finished within the last 10 seconds, the system automatically triggers an update. <br  />
 This ensures that the visual representation remains synchronized with the actual program state, even during idle periods.</p>
<h3><a class="anchor" id="autotoc_md27"></a>
Example Usage :</h3>
<p>Here's an example of how you might use Real-Time logs : (see <a class="el" href="_dispatch_q___unit_test_8cpp.html">DispatchQ_UnitTest.cpp</a>) </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_dispatch_q_8h.html">DispatchQ.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SimpleTest()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create a new dispatch queue</span></div>
<div class="line">    <a class="code hl_class" href="class_lz_async_1_1_dispatch_q.html">LzAsync::DispatchQ</a> dispatchQ(<span class="stringliteral">&quot;SimpleTest&quot;</span>, 3);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> pInstant = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordtype">int</span> lcount = 0;</div>
<div class="line"> </div>
<div class="line">    std::function&lt;void(<span class="keywordtype">void</span>)&gt; lJobDispatch;</div>
<div class="line">    lJobDispatch = [&amp;]()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">bool</span> localInstant = pInstant;</div>
<div class="line"> </div>
<div class="line">        dispatchQ.dispatch([localInstant]() {</div>
<div class="line">            <span class="keywordflow">if</span> (!localInstant)</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">        }, <span class="stringliteral">&quot;Job OK &quot;</span> + std::to_string(lcount));</div>
<div class="line"> </div>
<div class="line">        dispatchQ.dispatch([localInstant]() {</div>
<div class="line">            <span class="keywordflow">if</span> (!localInstant)</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Simple Test: This is a test.&quot;</span>);</div>
<div class="line">        }, <span class="stringliteral">&quot;Job KO &quot;</span> + std::to_string(lcount));</div>
<div class="line"> </div>
<div class="line">        lcount++;</div>
<div class="line">        pInstant = !pInstant;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (lcount &lt; 10)</div>
<div class="line">            lJobDispatch();</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    dispatchQ.startProfiling(<span class="stringliteral">&quot;./json_files/SimpleTest&quot;</span>, <a class="code hl_enumvalue" href="namespace_lz_async.html#a042255cfe6266c279099b1238d39443aa4abfc22ad3c3ef567d80c65263fd7754">LzAsync::LogsMod::REALTIME</a>);</div>
<div class="line">    lJobDispatch();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait for all jobs to finish</span></div>
<div class="line">    dispatchQ.waitForIdle(<span class="keyword">false</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This is what you should see in the GUI in Real-Time Mode: <br  />
 <img src="Screenshots_ReadMe/RealTimeSimple.png" alt="Simple Real Time Mode" class="inline"/></p>
<blockquote class="doxtable">
<p><b>What You See:</b></p><ul>
<li>As before, each rectangle represents a job: <br  />
<ul>
<li>üü© Green indicates a successful job <br  />
</li>
<li>üü• Red indicates a job that threw an exception <br  />
</li>
<li>üü™ Purple indicates a job that is still running <br  />
</li>
</ul>
</li>
<li>The flashing green and red lines represent successful and failed jobs that completed in less than a millisecond. <br  />
</li>
<li>If you hover over an unfinished (purple) job, you will see: <br  />
<ul>
<li>The job's name <br  />
</li>
<li>Its ID <br  />
</li>
<li>The start time </li>
</ul>
</li>
</ul>
</blockquote>
<hr  />
<h4><a class="anchor" id="autotoc_md29"></a>
DeadLocks:</h4>
<p>In Real-Time Mode, a deadlock detector is enabled by default. <br  />
 It detects deadlocks caused by cyclic mutex locks and will terminate the program if one is found.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
Example Usage :</h3>
<p>Here's an example of how you might use Real-Time logs : (see <a class="el" href="_dispatch_q___unit_test_8cpp.html">DispatchQ_UnitTest.cpp</a>) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> TestDeadlock1WithDispatchQ() </div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Creat a 2 thread Dispatch queue</span></div>
<div class="line">    <a class="code hl_class" href="class_lz_async_1_1_dispatch_q.html">LzAsync::DispatchQ</a> dispatchQ(<span class="stringliteral">&quot;DeadlockTestQ&quot;</span>, 2);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Share Mutexes that will cause the deadlock</span></div>
<div class="line">    std::mutex mutexA, mutexB;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Job 1 : take mutexA then try to take mutexB</span></div>
<div class="line">    <span class="keyword">auto</span> job1 = [&amp;]() {</div>
<div class="line">        MutexNeed(dispatchQ, <span class="stringliteral">&quot;mutexA&quot;</span>);</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lockA(mutexA);</div>
<div class="line">        MutexHave(dispatchQ, <span class="stringliteral">&quot;mutexA&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(100)); <span class="comment">// Simulate some work</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Try to take mutexB but block because job2 have it</span></div>
<div class="line">        MutexNeed(dispatchQ, <span class="stringliteral">&quot;mutexB&quot;</span>);</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lockB(mutexB);</div>
<div class="line">        MutexHave(dispatchQ, <span class="stringliteral">&quot;mutexB&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        MutexFree(dispatchQ, <span class="stringliteral">&quot;mutexA&quot;</span>);</div>
<div class="line">        MutexFree(dispatchQ, <span class="stringliteral">&quot;mutexB&quot;</span>);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Job 2 : take mutexB then try to take mutexA</span></div>
<div class="line">    <span class="keyword">auto</span> job2 = [&amp;]() {</div>
<div class="line">        MutexNeed(dispatchQ, <span class="stringliteral">&quot;mutexB&quot;</span>);</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lockB(mutexB);</div>
<div class="line">        MutexHave(dispatchQ, <span class="stringliteral">&quot;mutexB&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(100)); <span class="comment">// Simulate some work</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Try to take mutexA but block because job1 have it</span></div>
<div class="line">        MutexNeed(dispatchQ, <span class="stringliteral">&quot;mutexA&quot;</span>);</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lockA(mutexA);</div>
<div class="line">        MutexHave(dispatchQ, <span class="stringliteral">&quot;mutexA&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        MutexFree(dispatchQ, <span class="stringliteral">&quot;mutexB&quot;</span>);</div>
<div class="line">        MutexFree(dispatchQ, <span class="stringliteral">&quot;mutexA&quot;</span>);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    dispatchQ.startProfiling(<span class="stringliteral">&quot;./json_files/Deadlock1RealTimeTest&quot;</span>, <a class="code hl_enumvalue" href="namespace_lz_async.html#a042255cfe6266c279099b1238d39443aa4abfc22ad3c3ef567d80c65263fd7754">LzAsync::LogsMod::REALTIME</a>);</div>
<div class="line"> </div>
<div class="line">    dispatchQ.dispatch(job1, <span class="stringliteral">&quot;Job1_Deadlock&quot;</span>);</div>
<div class="line">    dispatchQ.dispatch(job2, <span class="stringliteral">&quot;Job2_Deadlock&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    dispatchQ.interruptJobs(<span class="keyword">false</span>);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;this line will never be printed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p> This is what you should see in the GUI in Real Time Mode: <br  />
 <img src="Screenshots_ReadMe/DeadLock.png" alt="DeadLock" class="inline"/></p>
<blockquote class="doxtable">
<p><b>What You See:</b> <br  />
</p><ul>
<li>We can see that the two threads have not finished their jobs due to the deadlock. <br  />
</li>
<li>Some mutexes are held by thread 1 and thread 2. <br  />
</li>
<li>A red line indicates where the deadlock was detected. <br  />
</li>
<li>Hovering your mouse over this red line shows a tooltip with detailed information about the deadlock. </li>
</ul>
</blockquote>
<hr  />
<h2><a class="anchor" id="autotoc_md32"></a>
Frontend (GUI)</h2>
<p>This section explains the main functionalities of the GUI and how it can help you debug your code.</p>
<p>The main window is organized as follows:</p>
<hr  />
<h3><a class="anchor" id="autotoc_md34"></a>
1. Central Area: Execution Timeline</h3>
<p>This area displays threads as horizontal lines, with jobs shown as colored rectangles indicating their state, positioned along a timeline in milliseconds. If you hover your mouse over a job, mutex, or tag, you will see information related to the hovered object.</p>
<p><img src="Screenshots_ReadMe/Timeline_Central.png" alt="Central Timeline with red box" class="inline"/></p>
<p><b>Animated example:</b> <br  />
 <img src="Screenshots_ReadMe/CenterGif.gif" alt="Timeline animation example" class="inline"/></p>
<hr  />
<ul>
<li><b>Time Navigation Slider</b> <br  />
 Allows scrolling through the timeline. It is also used in other funcionnalities we will see later.</li>
</ul>
<p><img src="Screenshots_ReadMe/Slider.png" alt="Slider Timeline with red box" class="inline"/></p>
<p><b>Animated example:</b> <br  />
 <img src="Screenshots_ReadMe/SliderGif.gif" alt="Slider animation example" class="inline"/></p>
<hr  />
<h3><a class="anchor" id="autotoc_md37"></a>
2. Top Toolbar</h3>
<ul>
<li><b>Zoom Mode Button</b> <br  />
 Toggles between panoramic view (time scale adjusted to show everything) and compressed view (time scale squeezed).</li>
</ul>
<p><img src="Screenshots_ReadMe/Toolbar_ZoomButton.png" alt="Toolbar with red box on Zoom button" class="inline"/></p>
<p><b>Animated example:</b> <br  />
 <img src="Screenshots_ReadMe/Toolbar_Zoom_Example.gif" alt="Zoom mode example" class="inline"/></p>
<hr  />
<ul>
<li><b>Reset Zoom Button</b> <br  />
 Resets the zoom and timeline configuration back to the default state.</li>
</ul>
<p><img src="Screenshots_ReadMe/Toolbar_ResetButton.png" alt="Toolbar with red box on Reset button" class="inline"/></p>
<p><b>Animated example:</b> <br  />
 <img src="Screenshots_ReadMe/Toolbar_Reset_Example.gif" alt="Reset zoom example" class="inline"/></p>
<hr  />
<ul>
<li><b>Loop Zoom Button</b> <br  />
 Enables or disables loop zoom mode (enable by defalut). When enabled, two sliders appear: <br  />
<ul>
<li>One slider to define the time range of the zoom <br  />
</li>
<li>One slider to adjust the zoom amount (2x to 20x) <br  />
</li>
</ul>
</li>
</ul>
<p><img src="Screenshots_ReadMe/Toolbar_LoopButton.png" alt="Toolbar with red box on Loop button" class="inline"/></p>
<p><b>Animated example:</b> <br  />
 <img src="Screenshots_ReadMe/Toolbar_Loop_Example.gif" alt="Loop zoom example" class="inline"/></p>
<hr  />
<h3><a class="anchor" id="autotoc_md41"></a>
3. Left Sidebar</h3>
<ul>
<li><b>Load File Button</b> <br  />
 Loads a JSON file containing the logs to visualize. <br  />
</li>
</ul>
<p><img src="Screenshots_ReadMe/Sidebar_LoadFileButton.png" alt="Left sidebar with red box on Load File button" class="inline"/></p>
<p><b>Animated example:</b> <br  />
 <img src="Screenshots_ReadMe/Sidebar_LoadFile_Example.gif" alt="Load File example" class="inline"/></p>
<hr  />
<ul>
<li><b>Mutex View Button</b> <br  />
 Toggles mutex coloring for better visualization of locks and access.</li>
</ul>
<p><img src="Screenshots_ReadMe/Sidebar_MutexViewButton.png" alt="Left sidebar with red box on Mutex View button" class="inline"/></p>
<p><b>Animated example:</b> <br  />
 <img src="Screenshots_ReadMe/Sidebar_MutexView_Example.gif" alt="Mutex View example" class="inline"/></p>
<hr  />
<ul>
<li><b>Job Heredity Button</b> <br  />
 Enables or disables displaying parent-child relationships between jobs. <br  />
 When enabled, you can adjust how many ascending or descending generations to show. <br  />
</li>
</ul>
<p><img src="Screenshots_ReadMe/Sidebar_HeredityButton.png" alt="Left sidebar with red box on Job Heredity button" class="inline"/></p>
<p><b>Animated example:</b> <br  />
 <img src="Screenshots_ReadMe/Sidebar_Heredity_Example.gif" alt="Heredity example" class="inline"/></p>
<hr  />
<h3><a class="anchor" id="autotoc_md45"></a>
4. Bottom Area: Textual Trace</h3>
<p>Displays detailed textual information about the execution, updated according to the time slider position.</p>
<p><img src="Screenshots_ReadMe/Textual_Log.png" alt="Bottom textual trace area" class="inline"/></p>
<p><b>Animated example:</b> <br  />
 <img src="Screenshots_ReadMe/Textual_Log.gif" alt="Bottom textual trace area exemple" class="inline"/></p>
<hr  />
<p>Together, these elements provide a powerful and intuitive interface to analyze multi-threaded executions, track job dependencies, visualize mutex usage, and debug complex synchronization issues.</p>
<h1><a class="anchor" id="autotoc_md47"></a>
Exemple</h1>
<h1><a class="anchor" id="autotoc_md48"></a>
Contribution</h1>
<p>[### Sous-titre + description avec exemple des commandes √† lancer pour l'ensemble du flux de contribution sur le d√©p√¥t]</p>
<h1><a class="anchor" id="autotoc_md49"></a>
Build with</h1>
<h2><a class="anchor" id="autotoc_md50"></a>
Langages &amp; Frameworks</h2>
<p>[Liste de tout ce qui permet la confection du projet avec description + lien vers la documentation]</p>
<h2><a class="anchor" id="autotoc_md51"></a>
Outils</h2>
<h3><a class="anchor" id="autotoc_md52"></a>
CI</h3>
<p>[Liste de tout ce qui permet l'int√©gration automatis√©e du projet avec description + lien vers la documentation et mise en avant des comptes, organisations et variables]</p>
<h3><a class="anchor" id="autotoc_md53"></a>
D√©ploiement</h3>
<p>[Liste de tout ce qui permet le d√©ploiement du projet avec description + lien vers la documentation et mise en avant des comptes, organisations et variables]</p>
<h1><a class="anchor" id="autotoc_md54"></a>
Documentation</h1>
<p>[Lien vers documentations externes ou documentation embarqu√©e ici avec table des mati√®res]</p>
<h1><a class="anchor" id="autotoc_md55"></a>
Gestion des versions</h1>
<p>Afin de maintenir un cycle de publication claire et de favoriser la r√©trocompatibilit√©, la d√©nomination des versions suit la sp√©cification d√©crite par la <a href="https://semver.org/lang/fr/">Gestion s√©mantique de version</a></p>
<p>Les versions disponibles ainsi que les journaux d√©crivant les changements apport√©s sont disponibles depuis [la page des Releases][mettre le lien ici].</p>
<h1><a class="anchor" id="autotoc_md56"></a>
Licence</h1>
<p>Voir le fichier LICENSE du d√©p√¥t. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
